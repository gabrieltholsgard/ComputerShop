DROP VIEW IF EXISTS NEEDED;
DROP VIEW IF EXISTS AVAILABILITY;
DROP VIEW IF EXISTS AVAILABLE;

DROP TRIGGER IF EXISTS calc_price_insert;
DROP TRIGGER IF EXISTS calc_price_update;
DROP TRIGGER IF EXISTS calc_price_delete;
DROP TRIGGER IF EXISTS update_component;

DROP TABLE IF EXISTS ORDER_ITEMS CASCADE;
DROP TABLE IF EXISTS ORDERS CASCADE;
DROP TABLE IF EXISTS COMPOSITION CASCADE;
DROP TABLE IF EXISTS BOOKS CASCADE;
DROP TABLE IF EXISTS AUTHORS CASCADE;
DROP TABLE IF EXISTS USER_ROLES CASCADE;
DROP TABLE IF EXISTS USERS CASCADE;


CREATE TABLE AUTHORS(
	AUTHOR_ID INT NOT NULL AUTO_INCREMENT, 
	NAME VARCHAR(50),
	SURNAME VARCHAR(50),
	QTY INTEGER,
	C_PRICE INTEGER,
	PRIMARY KEY(AUTHOR_ID)
);



CREATE TABLE BOOKS(
	BOOK_ID INT  NOT NULL AUTO_INCREMENT,
	AUTHOR_ID INT,
	TITLE VARCHAR(200), 
	DESCRIPTION BLOB, 
	PRICE NUMERIC(10,2), 
	AVAILABLE INT,
	PAGES INT,
	PROFIT INTEGER,
	VISIBLE BOOLEAN,
	PRIMARY KEY(BOOK_ID)
);



CREATE TABLE COMPOSITION (
	EL_ID INTEGER,
	COM_ID INTEGER,
	QTY INTEGER,
	PRIMARY KEY(EL_ID, COM_ID),
	FOREIGN KEY (EL_ID) REFERENCES BOOKS(BOOK_ID),
	FOREIGN KEY (COM_ID) REFERENCES AUTHORS(AUTHOR_ID)
);



CREATE TABLE ORDERS(
	ORDER_ID INT NOT NULL AUTO_INCREMENT,
	BUYER_NAME VARCHAR(100),
	SHIPPING_ADRESS VARCHAR(100),
	SHIPPING_ZIPCODE VARCHAR(10),
	SHIPPING_CITY VARCHAR(30),
	PRIMARY KEY(ORDER_ID)
);



CREATE TABLE ORDER_ITEMS(
	ORDER_ITEM_ID INT NOT NULL AUTO_INCREMENT,
	ORDER_ID INT,
	BOOK_ID INT,
	QUANTITY INT,
	PRIMARY KEY(ORDER_ITEM_ID),
	FOREIGN KEY(ORDER_ID) REFERENCES ORDERS(ORDER_ID),
	FOREIGN KEY(BOOK_ID) REFERENCES BOOKS(BOOK_ID)
);



CREATE TABLE USERS(
       USER_NAME varchar(15) not null primary key,
       USER_PASS varchar(15) not null,
       NAME varchar(100) not null,
       STREET_ADDRESS varchar(100)not null,
       ZIP_CODE varchar(10) not null,
       CITY varchar(30) not null,
       COUNTRY varchar(30) not null
);

CREATE TABLE USER_ROLES(
	USER_NAME varchar(15) not null,
	ROLE_NAME varchar(15) not null,
	primary key (USER_NAME, ROLE_NAME)
);


CREATE VIEW NEEDED AS SELECT BOOKS.BOOK_ID,BOOKS.TITLE, COMPOSITION.COM_ID, AUTHORS.NAME,
							 COMPOSITION.QTY, AUTHORS.QTY AS IN_STOCK, AUTHORS.C_PRICE,
							 BOOKS.PROFIT
	FROM BOOKS LEFT JOIN (COMPOSITION CROSS JOIN AUTHORS)
		ON (AUTHORS.AUTHOR_ID=COMPOSITION.COM_ID AND COMPOSITION.EL_ID = BOOKS.BOOK_ID);

CREATE VIEW AVAILABILITY AS SELECT BOOK_ID, TITLE, MIN(FLOOR(IN_STOCK / QTY)) AS AVAILABILITY,
								   SUM((QTY*C_PRICE)+PROFIT) AS FINAL_PRICE
	FROM NEEDED GROUP BY BOOK_ID;


CREATE VIEW AVAILABLE AS
	SELECT book_id, MIN(FLOOR(a.qty / c.qty)) AS available,
			(SUM(c.qty * c_price) + profit) AS final_price
	FROM books, composition AS c, authors AS a
	WHERE book_id = el_id AND com_id = a.author_id
	GROUP BY book_id;


CREATE TRIGGER calc_price_insert
	AFTER INSERT ON composition FOR EACH ROW
	UPDATE books as b, available as a
	SET b.price = a.final_price, b.available = a.available
	WHERE	b.book_id = NEW.el_id AND a.book_id = NEW.el_id;


CREATE TRIGGER calc_price_update
	AFTER UPDATE ON composition FOR EACH ROW
	UPDATE books as b, available as a
	SET b.price = a.final_price, b.available = a.available
	WHERE b.book_id = NEW.el_id AND a.book_id = NEW.el_id;


CREATE TRIGGER calc_price_delete
	AFTER DELETE ON composition FOR EACH ROW
	UPDATE books as b, available as a
	SET b.price = a.final_price, b.available = a.available
	WHERE b.book_id = OLD.el_id AND a.book_id = OLD.el_id;
