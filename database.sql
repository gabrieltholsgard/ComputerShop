DROP VIEW IF EXIST NEEDED;
DROP VIEW IF EXIST AVAILABILITY;
DROP VIEW IF EXIST AVAILABLE;

DROP TRIGGER IF EXIST calc_price_insert;
DROP TRIGGER IF EXIST calc_price_update;
DROP TRIGGER IF EXIST calc_price_delete;
DROP TRIGGER IF EXIST update_component;

DROP TABLE IF EXIST ORDER_ITEMS CASCADE;
DROP TABLE IF EXIST ORDERS CASCADE;
DROP TABLE IF EXIST COMPOSITION CASCADE;
DROP TABLE IF EXIST BOOKS CASCADE;
DROP TABLE IF EXIST AUTHORS CASCADE;
DROP TABLE IF EXIST USER_ROLES CASCADE;
DROP TABLE IF EXIST USERS CASCADE;


CREATE TABLE AUTHORS(
	AUTHOR_ID INT NOT NULL AUTO_INCREMENT, 
	NAME VARCHAR(50),
	SURNAME VARCHAR(50),
	QTY INTEGER,
	C_PRICE INTEGER,
	PRIMARY KEY(AUTHOR_ID)
);



CREATE TABLE BOOKS(
	BOOK_ID INT  NOT NULL AUTO_INCREMENT, 
	TITLE VARCHAR(200), 
	DESCRIPTION BLOB, 
	PRICE NUMERIC(5,2), 
	AVAILABLE INT,
	PROFIT INTEGER,
	VISIBLE BOOLEAN,
	PRIMARY KEY(BOOK_ID)
);



CREATE TABLE COMPOSITION (
	EL_ID INTEGER,
	COM_ID INTEGER,
	QTY INTEGER,
	PRIMARY KEY(EL_ID, COM_ID),
	FOREIGN KEY (EL_ID) REFERENCES BOOKS(BOOK_ID),
	FOREIGN KEY (COM_ID) REFERENCES AUTHORS(AUTHOR_ID)
);



CREATE TABLE ORDERS(
	ORDER_ID INT NOT NULL AUTO_INCREMENT,
	BUYER_NAME VARCHAR(100),
	SHIPPING_ADRESS VARCHAR(100),
	SHIPPING_ZIPCODE VARCHAR(10),
	SHIPPING_CITY VARCHAR(30),
	PRIMARY KEY(ORDER_ID)
);



CREATE TABLE ORDER_ITEMS(
	ORDER_ITEM_ID INT NOT NULL AUTO_INCREMENT,
	ORDER_ID INT,
	BOOK_ID INT,
	QUANTITY INT,
	PRIMARY KEY(ORDER_ITEM_ID),
	FOREIGN KEY(ORDER_ID) REFERENCES ORDERS(ORDER_ID),
	FOREIGN KEY(BOOK_ID) REFERENCES BOOKS(BOOK_ID)
);



CREATE TABLE USERS(
       USER_NAME varchar(15) not null primary key,
       USER_PASS varchar(15) not null,
       NAME varchar(100) not null,
       STREET_ADDRESS varchar(100)not null,
       ZIP_CODE varchar(10) not null,
       CITY varchar(30) not null,
       COUNTRY varchar(30) not null
);

CREATE TABLE USER_ROLES(
	USER_NAME varchar(15) not null,
	ROLE_NAME varchar(15) not null,
	primary key (USER_NAME, ROLE_NAME)
);


INSERT INTO AUTHORS(NAME, SURNAME) VALUES('GREG',    'BARISH');
INSERT INTO AUTHORS(NAME, SURNAME) VALUES('TIMOTHY', 'BUDD');
INSERT INTO AUTHORS(NAME, SURNAME) VALUES('MARK',    'WUTKA');
INSERT INTO AUTHORS(NAME, SURNAME) VALUES('H.M',     'DIETEL');

INSERT INTO BOOKS(AUTHOR_ID, TITLE, DESCRIPTION, PRICE, PAGES) VALUES(
	1,
	'BUILDNING SCALABLE AND HIGH-PERFORMANCE JAVA WEB APPLICATIONS USING J2EE TECHNOLOGY',
	'A BOOK ABOUT BUILDNING SCALABLE AND HIGH-PERFORMANCE JAVA WEB APPLICATIONS USING J2EE TECHNOLOGY. THE BOOKS DESCRIBES HOW TO USE THE DIFFERENT PARTS OF J2EE TO BUILD A WEB APPLICATION',
	600, 392);
INSERT INTO BOOKS(AUTHOR_ID, TITLE, DESCRIPTION, PRICE, PAGES) VALUES(
	2,
	'CLASSIC DATA STRUCTURES IN C++',
	'BUDD EXPLAINS SEVERAL DATA STRUCTURES THAT ARE COMMIN IN C++',
	550, 537);
INSERT INTO BOOKS(AUTHOR_ID, TITLE, DESCRIPTION, PRICE, PAGES) VALUES(
	2,
	'CLASSIC DATA STRUCTURES IN JAVA',
	'BUDD EXPLAINS SEVERAL DATA STRUCTURES THAT ARE COMMIN IN JAVA',
	650, 437);
INSERT INTO BOOKS(AUTHOR_ID, TITLE, DESCRIPTION, PRICE, PAGES) VALUES(
	3,
	'SPECIAL EDITION USING JAVA SERVER PAGES',
	'A QUITE EXTENSIVE BOOK ABOUT WEB DEVELOPMENT USING JAVA SERVER PAGES AND JAVA SERVLETS',
	400, 351);
INSERT INTO BOOKS(AUTHOR_ID, TITLE, DESCRIPTION, PRICE, PAGES) VALUES(
	4,
	'C: HOW TO PROGRAM',
	'AN INTRODUCTION TO C-PROGRAMMING.',
	430, 800);

INSERT INTO USERS(USER_NAME, USER_PASS, NAME, STREET_ADDRESS, ZIP_CODE, CITY, COUNTRY) 
     VALUES('tomcat','tacmot','Tom Cat','Apache Road', '34 567', 'Petaluma', 'USA');
INSERT INTO USERS(USER_NAME, USER_PASS, NAME, STREET_ADDRESS, ZIP_CODE, CITY, COUNTRY) 
     VALUES('gyro','glurk','Gyro Gearloose','Duck Road', '78 901', 'Ducksbury', 'USA');
INSERT INTO USERS(USER_NAME, USER_PASS, NAME, STREET_ADDRESS, ZIP_CODE, CITY, COUNTRY) 
     VALUES('admin', 'glurk','System user', 'Polacksbacken', '752 37', 'Uppsala', 'Sweden');

INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('tomcat','tomcat');
INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('gyro',  'tomcat');
INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('admin', 'manager');
INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('admin', 'admin');
INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('admin', 'tomcat');
INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('admin', 'manager-script');
INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('admin', 'manager-gui');
INSERT INTO USER_ROLES(USER_NAME, ROLE_NAME) VALUES('admin', 'admin-gui');

INSERT INTO COMPOSITION VALUES (1,1,2);
INSERT INTO COMPOSITION VALUES (1,2,3);
INSERT INTO COMPOSITION VALUES (2,3,3);
INSERT INTO COMPOSITION VALUES (3,1,3);
INSERT INTO COMPOSITION VALUES (3,2,2);
INSERT INTO COMPOSITION VALUES (3,3,3);
INSERT INTO COMPOSITION VALUES (4,3,3);
INSERT INTO COMPOSITION VALUES (4,2,1);
INSERT INTO COMPOSITION VALUES (4,1,10);
INSERT INTO COMPOSITION VALUES (5,1,10);

UPDATE BOOKS SET PROFIT = 10 WHERE BOOK_ID > 0;
UPDATE BOOKS SET VISIBLE = TRUE WHERE BOOK_ID > 0;
UPDATE AUTHORS SET QTY = 100 WHERE AUTHOR_ID > 0;
UPDATE AUTHORS SET C_PRICE = 150 WHERE AUTHOR_ID > 0;


CREATE VIEW AVAILABLE AS
	SELECT book_id, MIN(FLOOR(a.qty / c.qty)) AS available,
			(SUM(c.qty * c_price) + profit) AS final_price
	FROM books, composition AS c, authors AS a
	WHERE book_id = el_id AND com_id = a.author_id
	GROUP BY book_id;


DELIMITER $$

CREATE TRIGGER calc_price_insert
	AFTER INSERT ON composition FOR EACH ROW
	UPDATE books as b, authors as a
	SET b.price = (NEW.qty * a.c_price) + b.profit, b.available = 
	WHERE	b.book_id = NEW.el_id AND
		NEW.el_id = OLD.el_id AND
		NEW.com_id = OLD.com_id;

DELIMITER ;

CREATE TRIGGER calc_price_update
	AFTER UPDATE ON composition FOR EACH ROW
	UPDATE books as b, authors as a
	SET b.price = (b.price + ((NEW.qty * a.c_price) - (OLD.qty * a.c_price)))
	WHERE b.book_id = NEW.el_id AND NEW.el_id = OLD.el_id AND NEW.com_id = OLD.com_id;


CREATE TRIGGER calc_price_delete
	AFTER DELETE ON composition FOR EACH ROW
	UPDATE books as b, authors as a
	SET b.price = (b.price - (OLD.qty * a.c_price))
	WHERE b.book_id = OLD.el_id;


DELIMITER $$

CREATE TRIGGER update_component
	AFTER UPDATE ON authors FOR EACH ROW
	IF NEW.c_price != OLD.c_price THEN
		UPDATE books as b, composition as c
		SET b.price = ((b.price - (c.qty * OLD.c_price)) + (c.qty * NEW.c_price))
		WHERE NEW.author_id = c.com_id and c.el_id = b.book_id;
	END IF;
	IF NEW.qty != OLD.qty THEN
		UPDATE books as b,
	END IF$$

DELIMITER ;

